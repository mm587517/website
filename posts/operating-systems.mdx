---
author: Marcelo Morales
title: Operating Systems
banner: https://media.istockphoto.com/photos/on-digital-interface-and-blue-network-background-picture-id1130990010?k=20&m=1130990010&s=612x612&w=0&h=6DcPO6xYTQ64DpFlxqRDepkV9t58K8fjbHfZnUGCbOs=
---

This post serves as a study guide. All the links for the information can be found at the end of each section. I do not claim it as my own. This page is an organization of topics. 

<Section section="Process Synchronization">
  
  ### Process

  <Box question="What is a process?">
    We can define a process as a program that is currently being executed.
  </Box>

  <Box question="What are the states of a process?">

      - Ready: ready for execution
      - Running: executing process
      - Blocked: waiting or blocked until another process gives the all clear

      ![States of a Process](https://media.geeksforgeeks.org/wp-content/uploads/20220114144811/state-660x365.PNG)

  </Box>

  <Box question="What are the types of concurrent unit control?">
      - Physical Concurrency
      - Logical Concurrency

      <Box question="when do they occurr?">
          - Phyical occurs when two or more processors are running simultaneously
          - Logical happens when execution happens in intervals in a single processor
      </Box>

  </Box>

  <Box question="How do concurrent processes interact with each other?">
    - shared variables: processes read and write to shared memory 
      - ![Shared Svariables](https://web.mit.edu/6.005/www/fa14/classes/17-concurrency/figures/shared-memory.png)
    - message passing: messages are sent through communication channels 
      -![Message passing](https://web.mit.edu/6.005/www/fa14/classes/17-concurrency/figures/message-passing.png)
  </Box>

  ### Critical Sections

  <Box question="What is a critical section?">
    Region of code that needs to be executed atomically since resources are shared
  </Box>

  <Box question="Solution to the critical section problem?">
    - <Box question="Busy Waiting">
        Technique in which a process/task waits and constantly checks for a condition to be satisfied before proceeding with its execution
        ![Busy Waiting](https://www.baeldung.com/wp-content/uploads/sites/4/2021/08/Busywaiting.svg)
      </Box>
    - <Box question="Disabling Interrupts">
        - The CPU will be unable to switch processes
        - Processes can use shared variables without another process accessing it
      </Box>
    - <Box question="Test-and-Set Intruction">
        - Shared variable is lock which is initialized to false
        - Algorithm returns value that was sent and sets lock to true
        ```c
          boolean lock = false;

          boolean TestAndSet (boolean &target){
              boolean rv = target;
              target = true;
              return rv;
          }

          while(1){
              while (TestAndSet(lock));
              critical section
              lock = false;
              remainder section
          }
        ```
      </Box>
  </Box>

  ### Semaphores

  <Box question="What is a semaphore?">
    It is similar to an integer but differs in:
      - value can only be increased or decreased. No reading occurs
      - after decreasing, if the value is negative then the thread is blocked until the semaphore is positive
      - once a thread is released and increases the value of the semaphore, one waiting thread gets accesss
  </Box>

  <Box question="Does the semaphore have atomic operations?">
    Yes
    - P(S): decrements the value
    - V(S): increments the value 

    ```c
    sem = Semaphore(1)

    // Process
    sem.P()
      // critical section
    sem.V()
    ```
  </Box>

  <Box question="Why use semaphores?">
    - Solutions are clean
    - Solutions are portable and efficient
  </Box>

  <Box question="Difference between locks, mutex semaphore?">
    - lock allows only one thread to enter the part that's locked and the lock is not shared with any other processes
    - mutex is the same as a lock but it can be system wide
    - semaphore does the same as a mutex but allows x number of threads to enter
  </Box>

  #### Producer Consumer Problem

  <Box question="What is this Producer Consumer Problem?">
    Producer threads create items and place them in a buffer, meanwhile consumer threads remove them from the buffer.
    Producer threads should not be able to create items if the buffer is full, and consumers should not be able to remove items if buffer is empty. 
  </Box>

  <Box question="Infinite Buffer Example">
    Code can be found on page 57 of Litte Book of semaphores

    ```ts
      buffer: number[] = [];
      mutex: semaphore = 1;
      items: semaphore = 0;
      
      Producer {
        mutex.P() // lock the mutex
          buffer.add(item)
          items.V() // increase number of items for consumer threads
        mutex.V() // release mutex
      }

      Consumer {
        items.P() // decrease number of items
        mutex.P() 
          buffer.pop() // remove item from buffer
        mutex.V()
      }
    ```
    <Box question="What is wrong with this implementation? How to fix it?">
      <Box question="Producer">
          Assume $mutex = 1$ at the start of the producer.
          1. mutex.P() inside Producer makes $mutex = 0$
          2. items.V() inside Producer can trigger a consumer thread
          3. items.P() inside Consumer makes $mutex = -1$
          4. mutex.V() inside Producer makes $mutex = 0$
          
          This means we cannot enter the critical section inside the consumer. In order to proceed the semaphore value has to be greater than 0

          The fix is to signal the consumer after we are out of the critical section.

          ```ts
            buffer: number[] = [];
            mutex: semaphore = 1;
            items: semaphore = 0;
            
            Producer {
              mutex.P() // lock the mutex
                buffer.add(item)
              mutex.V() // release mutex
              items.V() // increase number of items and signal consumer threads
            }
          ```
      </Box>
    
      <Box question="Consumer">
        Various consumers can decrement value of items before popping. This leads to incorrect count. Consider this:

        ```ts
            Consumer {
              mutex.P() 
                items.P() // decrease number of items
                buffer.pop() // remove item from buffer
              mutex.V()
            }

        ```
        Assume $items = 0$
        1. The consumer thread grabs the mutex
        2. items.P() in Consumer gets stuck since the value is not greater than 0
        3. Producer thread cannot increment the value of items, since it's waiting on the consumer to release the mutex

        We have reached a deadlock.
      </Box>
    </Box> 
  </Box>

  <Box question="Finite Buffer Example">

    Recall that a producer cannot create new items if buffer is full. Also, the consumer cannot retrieve items if buffer is empty. 

    ```ts
    const bufferSize: number = N;
    items: semaphore = 0;
    ...
    if (items >= bufferSize)
      block()
    ...
    ```

    <Box question="Would this work?">
      No, we cannot read the value of a semaphore. Only increase and decrease.
    </Box>

    <Box question = "Solution">
      We can add one more semaphore and set it equal to the size of the buffer.
      
      ```ts
        buffer: number[bufferSize];
        mutex: semaphore = 1;
        items: semaphore = 0;
        spaces: semaphore = bufferSize;

        Producer {
          spaces.P(); // decrement number of available spaces
          mutex.P();
            buffer.add()
          mutex.V();
          items.V() // signal the consumer
        }

        Consumer {
          items.P(); // decrement number of items in buffer
          mutex.P();
            buffer.pop();
          mutex.V();
          spaces.V(); // increment spaces
        }
      ```
    </Box>
  </Box>


  #### Readers-Writers Problem

  Little Book of Semaphores 4.2

  <Box question="What is the readers-writers problem?">
    Occurs when a resource is read and written by concurrent threads. Ideally, you do not want to read the resource while it is being written.
  </Box>

  <Box question="What are the constraints?">
    - Multiple readers can be in the critical section simultaneously
    - Writers have exclusive access to the critical section
  </Box>

  <Box question="Implementation">

    ```ts
      isRoomEmpty: semaphore = 1;
      mutex: semaphore = 1;
      readers: number = 0;

      Reader {
        mutex.P();
          readers++;
          if(readers == 1) isRoomEmpty.P(); // first reader locks the room
        mutex.V();

        <READ/>

        mutex.P();
          readers--;
          if(readers == 0) isRoomEmpty.V(); // last readers frees the room
        mutex.V();
      }

      Writer {
        isRoomEmpty.P(); // writer waits for room to be empty
          <WRITE/>
        isRoomEmpty.V();
      }
    ```
  </Box>

  <Box question="Starvation">
    In the previous implementation, writers can starve. This means that readers can keep coming in and writers _might_ wait forever. 

    <Box question="Make it so that when a writer arrives, exisiting readers finish.">
        ```ts
          isRoomEmpty: semaphore = 1;
          mutex: semaphore = 1;
          turnstile: semaphore = 1;
          readers: number = 0;

          Reader {
            turnstile.P(); // decrease number
            turnstile.V(); // the final increase to reach 1 is given by the writer

            mutex.P();
              readers++;
              if(readers == 1) isRoomEmpty.P(); // first reader locks the room
            mutex.V();

            <READ/>

            mutex.P();
              readers--;
              if(readers == 0) isRoomEmpty.V(); // last readers frees the room
            mutex.V();
          }

          Writer {
            turnstile.P(); // let readers know a writer came in
            isRoomEmpty.P(); // writer waits for room to be empty
              <WRITE/>
            turnstile.V(); // notify readers
            isRoomEmpty.V(); // room is ready
          }
        ```
    </Box>
  </Box>

  <Box question="Writer priority">
    Little Book of Semaphores page 79
        ```ts
          readerMutex: semaphore = 1;
          readers: number = 0;

          writerMutex: semaphore = 1;
          writers: number = 0;

          allowReaders: semaphore = 1;
          allowWriters: semaphore = 1;

          Reader {
            allowReaders.P();
              readerMutex.P();
                readers++;
                if(readers == 1) allowWriters.P(); // notify writers that readers are there
              readerMutex.V();
            allowReaders.V();

            <READ/>

            readerMutex.P();
              readers--;
              if(readers == 0) allowWriters.V(); //signal writers the are no more readers
            readerMutex.V();
          }

          Writer {
            writerMutex.P();
              writers++;
              if (writers == 1) allowReaders.P(); // notify readers to wait
            writerMutex.V();

            allowWriters.P();
              <WRITE/>
            allowWriters.V();

            writerMutex.P();
              writers--;
              if(writers == 0) allowReaders.V();
            writerMutex.V();
          }
        ```
  </Box>

  #### Dining Philosophers Problem

  Little Book of Semaphores 4.4

  <Box question="What is the Dining Philosophers Problem?">

    ![Dining Philosophers Problem](https://w3.cs.jmu.edu/kirkpams/OpenCSF/Books/csf/html/_images/CSF-Images.8.3.png)

    A philosopher needs _two_ forks to eat. Looking at the diagram, we can tell some of them will have to wait for an adjacent philosopher to finish eating.

    Each philosopher, representing a thread, runs the following loop:

    ```ts
      while (true) {
        think();
        getForks();
        eat();
        putForks();
      }
    ```

    Each philosopher knows their number ranging from 0 to $n$. Each fork is also numbered from 0 to $n$. A philosopher $i$ grabs the left fork $i$ and the right fork $i+1$

    The problem lies in the function $getForks()$ and $putForks()$. We need to implement them such that:
    - Only one philosopher can hold a fork at a time
    - No deadlocks
    - No starvation
    - Multiple philosophers eating
  </Box>


  <Box question="Solutions">
    ```ts
      const getForks = (i: number) => {
        forks[getLeft(i)].P();
        forks[getRight(i)].P();
      }

      const putForks = (i: number) => {
        forks[getLeft(i)].V();
        forks[getRight(i)].V();
      }
    ```
    <Box question="Does this solution work?">
      No. Imagine each philosopher picks up the fork to the right. There are no more forks available, and each philosphre only has one fork. No one can eat, thus leading to a deadlock.
    </Box>

    <Box question="Can it be improved?">
      We can ensure no deadlock as long as we leave one fork available. Say there are 5 forks, 5 philosophers, but we only allow 4 to eat. In the scenario where everyone reaches for a fork on the right, there will be one spare fork since one philosopher is not eating.
      We can implement this with a semaphore initialized to $n-1$, $n$ being the number of philosophers.

      ```ts
        maxPhilosophers: semaphore = n - 1;

        const getForks = (i: number) => {
          maxPhilosophers.P(); // only the first n - 1 philosophers can proceed

          forks[getLeft(i)].P();
          forks[getRight(i)].P();
        }

        const putForks = (i: number) => {
          forks[getLeft(i)].V();
          forks[getRight(i)].V();

          maxPhilosophers.V(); // notify the waiting philopher they can eat
        }
      ```
    </Box>
  </Box>

  ### Monitors

  <Box question="What is a monitor?">
    Collection of variables and procedures. Kinda like a class. 

    ```ts
      interface Condition {
        wait, // Process performing will be suspended and placed in the local queue
        signal, // One of the queued processes is popped
        queue // local queue of pending processes 
      }

      Monitor Test{
        variables: any;
        myConditions: Condition;

        procedure pn {...}
      }
    ```
  </Box>

  <Box question="Properties of monitors">
    - Outside processes cannot access the monitor's variables, but can call the procedures
    - Only one process at a time can execute code inside the monitor
  </Box>

  #### Producer Consumer Problem

  <Box question="Implementation">

    ```ts
    Monitor ProducerConsumer {
      items: number = 0; // # of items inside buffer
      full: condition;
      empty: condition;

      Procedure Produce {
        if (items == N) full.wait(); // can't produce since buffer is full
        <PRODUCE/> // should have released the wait
        items++;
        empty.signal(); // notify buffer is NOT empty & consumer can proceed
      }

      Procedure Consume {
        if (items == 0) empty.wait(); // can't consume since buffer is empty
        <CONSUME/>
        items--;
        full.signal(); // notify producer buffer is no longer full
      }
    }
    ```
  </Box>

  #### Readers-Writers Problem
  <Box question="Readers Priority">

    ```ts
    Monitor ReaderWriter {
      readers: number = 0;
      busy: boolean = false;
      reader: condition;
      writer: condition;

      Procedure beginRead {
        if (busy) reader.wait(); // wait until writer is done
        readers++;
        reader.signal(); // signal readers
      }

      Procedure endRead {
        reader--;
        if(readers == 0) writers.signal(); // notify writers there are no more readers
      }

      Procedure beginWrite {
        if(readers > 0 || busy) writer.wait(); // either reading or writing in process
        busy = true; // preparation
        writer.signal(); // notify writer it can proceed
      }

      Procedure endWrite {
        busy = false; // writer has finished
        if(reader.queue) reader.signal(); // notify reader it can proceed
        else writer.signal(); // if no readers, go to writer
      }
    }
    ```
  </Box>

  Geeks for Geeks:
  <Box question="Semaphores vs Monitors">
    - Mutual exclusion in monitors is automatic while in semaphores, mutual exclusion needs to be implemented explicitly.
    - Shared variables are global to all processes in the monitor while shared variables are hidden in semaphores
    - Semaphores permit more than one thread to access the critical section, unlike monitors.
    - In semaphores there is no spinning, hence no waste of resources due to no busy waiting.
  </Box>

  ### References
  <Box question="Sources">
    - [Three State Process Model in Operating System](https://www.geeksforgeeks.org/three-state-process-model-in-operating-system/)
    - [What Does “Busy Waiting” Mean in Operating Systems?](https://www.baeldung.com/cs/os-busy-waiting)
    - [What is mutual exclusion by using interrupt disabling?](https://www.tutorialspoint.com/what-is-mutual-exclusion-by-using-interrupt-disabling#:~:text=Whenever%20the%20interrupts%20are%20disabled,without%20another%20process%20accessing%20it.)
    - [Hardware Synchronization Algorithms : Unlock and Lock, Test and Set, Swap](https://www.geeksforgeeks.org/hardware-synchronization-algorithms-unlock-and-lock-test-and-set-swap/)
    - [Little Book of Semaphores](https://greenteapress.com/semaphores/LittleBookOfSemaphores.pdf)
    - [What is the difference between lock, mutex and semaphore?](https://stackoverflow.com/questions/2332765/what-is-the-difference-between-lock-mutex-and-semaphore)
    - [Monitors in Process Synchronization](https://www.geeksforgeeks.org/monitors-in-process-synchronization/)
    - [Monitor vs Semaphore](https://www.geeksforgeeks.org/monitor-vs-semaphore/)
  </Box>
</Section>

## Process Communication
Distributed Systems 3rd edition (2017) Chapter 4

### Message Passing Model

<Box question="Why do Distributed Systems use message passing?">
  Distributed Systems send and receive low level messages due to the absence of shared memory.
</Box>

<Box question="In a very high level, how does it work?">
  Say process $P$ wants to communicate with with process $Q$.
  1. $P$ builds message in local address space
  2. Sytem call sends message to $Q$
  3. Both $P$ and $Q$ need to agree on what was sent
</Box>

### OSI Model

<Box question="What is the OSI Model?">
  The Open Systems Interconnection Model identifies the various levels of communication, their purpose, as well as naming them.
  It is designed to allow open systems to communicate by using _communication protocols_.
</Box>

<Box question="Why use layers in the OSI Model? How many are there?">
  Each layer offers one or more specific communication services to the layer above it. In this way, the problem of getting a message
  from A to B can be divided into manageable pieces, each of which can be solved independently of the others.

  7 Layers:
  - Physical Layer
  - Data Link Layer
  - Network Layer
  - Transport Layer
  - Session Layer
  - Presentation Layer
  - Application Layer
</Box>

<Box question="Common Protocols">
  - File Transport Protocol (FTP)
  - HyperText Transport Protocol (HTTP)
  - Secure Shell (SSH)
</Box>

### Middleware Protocols

<Box question="What is middleware">
  Application that lives in the OSI application layer, but contains many general-purpose protocols that warrant their own layers.
</Box>

<Box question="What effect did it have on the OSI model?">
  It replaces the session and presentation layer
</Box>

### Berkeley Sockets

<Box question="What is a socket?">
  One endpoint of a two way communication link between two programs running on the network.
</Box>

<Box question="What are the socket operations for TCP?">
  - socket: creates new communication endpoint
  - bind: attaches local address to socket
  - listen: readiness to accept client connection requests
  - accept: block caller until connection request arrives
  - connect: actively attempts to establish connection
  - send: send data over connection
  - receive: receive data over connection
  - close: release connection
</Box>

<Box question="Describe the communication pattern">
  Server side executes the first 4 operations in order:

  $ socket \rightarrow bind \rightarrow listen \rightarrow accept $

  1. When _socket_ is called, caller creates new communication endpoint. The OS reserves resources for the specified resource.
  2. _bind_ associates local address with newly created socket. This tells the OS to receive messages on specified address and ports.
  3. _listen_ us called only in the case of connection-oriented communication. Allows OS to reserve buffers for specified amount of pending connection requests that are to be accepted.
  4. _accept_ blocks callers until receiving connection request. When request arrives, OS creates copy of the socket and returns it to the caller.

  Now we look at the client side. 

  5 . _connect_ requires caller to specify where a connection request is to be sent. Client is blocked until connection is established. 
  
  - Both client and server perform _send_ and _receive_ operations.

  8 . _close_ is a symmetric operation. 

  ![Socket Pattern](https://media.geeksforgeeks.org/wp-content/uploads/20200509144631/223-1.png)
</Box>


### Remote Procedure Call

**Distributed Systems 3rd edition (2017) 4.2**


<Box question="What is the basic idea of Remote Procedure Call?">
  Allow programs to call procedures located on other machines.

  When a process on machine A calls a procedure on machine B: 
  1. calling process on A is suspended, and 
  2. execution of the called procedure takes place on B

  Information can be transported from the caller to the callee in the parameters and can come back in 
  the procedure result
</Box>

<Box question="What can cause issues?">
  - Procedures being executed in different address spaces
  - Passing of parameters and results
  - Either or both machines crashing
</Box>

<Box question="Is RPC transparent?">
  Yes, the goal if that the calling procedure should not be aware that the called procedure is executing on a different machine or vice versa.
  In simple words, we want to make it look like local procedure.
</Box>

<Box question="Single machine procedure call">
  ```c
    newlist = append(data, dbList);
  ```

  Assumptions:
  - dbList is globally defined
  - data is the element to be appended

  Observations:
  - dbList is a reference to a list
  - data is a value


  1. $ append(data, dbList) $ pushes the representations of data & dbList into the stack
  2. Representations are now accessible by append's implementation

  - stack before the call to append
  ![Stack before](https://encrypted-tbn0.gstatic.com/images?q=tbn:ANd9GcQSZyRul-Q3hJJ681SBY9FBE2yfhrNg3Py9r8IpBf0xorHUk9RvpwkY1aq7mjk0qi_z7_c&usqp=CAU)

  - stack while the called procedure is active
  ![Stack After](data:image/png;base64,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)
</Box>

<Box question="What is a stub?">
  A stub is a piece of code that translates parameters sent between the client and server during a remote procedure call.
</Box>

<Box question="Why do stubs convert messages?">
  The client and server use different address spaces, so parameters used in function calls have to be converted, otherwise 
  the values of those parameters could not be used, because pointers to parameters in one computer's memory would point to 
  different data on the other computer. The client and server may also use different data representations, even for simple 
  parameters (e.g., big-endian versus little-endian for integers).
</Box>

<Box question="Client stub vs server stub">
  -  Client stubs convert parameters used in function calls and reconvert the result obtained from the server after function execution
  -  Server stubs reconvert parameters passed by clients and convert results back after function execution
  ![RPC between Client and Server](http://csis.pace.edu/~marchese/SE765/L7/L7_files/image016.jpg)
</Box>

<Box question="Steps of a RPC">
  1. Client calls client stub
  2. Client stubs builds message
  3. Client's OS sends message to remote OS
  4. Remote OS gives message to server stub
  5. Server stub unpacks message
  6. Server performs operation and returns result to the stub
  7. Server stub builds message
  8. Server OS sends message to client OS
  9. Client OS gives message to client stub
  10. Client stub unpacks message

  ![Steps involved](https://wachemo-elearning.net/wp-content/uploads/2022/08/image-824.png)
</Box>

<Box question="Stub Generation">
  Conside the following function:
  ```c
    void foobar(char x, float y, int z[5]){...}
  ```

  Assuming a word is four bytes:
    - char is one by
    - float is a whole word
    - array is group of words equal to array length

  Using these rules, the following message if formed:

  ![Stub Generation](http://csis.pace.edu/~marchese/CS865/Lectures/Chap4/Chapter4_files/image024.jpg)

  Server stub know the format that is being used.

  <Box question="Is agreeing on the format enough?">
    No. Client and server need to agree on representation of data structures. 
  </Box>
</Box>

<Box question="When to use Asynchronous RPC?">
  To support situations in which there no result to return to the client 

  <Box question="How does it work?">
    - Server immediately sends reply to client upon request arrival
    - Reply acts as acknowledgment to client
    - Client will unblock as soon as acknowledgment arrives

    ![Async RPC](https://d3i71xaburhd42.cloudfront.net/6fa6b5bc123c47d91d3a7afa41b39235dbaa25f1/11-Figure2-7-1.png)
    a. shows traditional RPC (notice how the procedure finishes on the server and then sends results to client)
    
    b. Async RPC (acknowledgment is sent, then starts working on procedure)
  </Box>
</Box>

<Box question="Deferrred synchronous RPC?">
  Occurs when reply will be returned but client is not prepared to wait for it and do nothing in the meantime. 

  1. Client calls servers, waits for acceptance and continues
  2. Server gets results
  3. Server sends response to client
  4.  _callback_ in client's side is initiated
  5. Client sends acknowledgment to server

  ![Async RPC 2](http://csis.pace.edu/~marchese/CS865/Lectures/Chap4/Chapter4_files/image030.jpg)
</Box>

### References

<Box question="Sources">
  - [Distributed Systems 3rd edition (2017)](https://www.distributed-systems.net/index.php/books/ds3/)
  - [Socket in Computer Network](https://www.geeksforgeeks.org/socket-in-computer-network/)
  - [Stub Generation in Distributed System](https://www.geeksforgeeks.org/stub-generation-in-distributed-system/)
  - [What Does Stub Mean?](https://www.techopedia.com/definition/27680/stub-distributed-computing#:~:text=Client%20stubs%20convert%20parameters%20used,generated%20either%20manually%20or%20automatically.)
  - [Stub (distributed computing)](https://en.wikipedia.org/wiki/Stub_(distributed_computing))
</Box>
