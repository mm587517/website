---
author: Marcelo Morales
title: Operating Systems
banner: https://media.istockphoto.com/photos/on-digital-interface-and-blue-network-background-picture-id1130990010?k=20&m=1130990010&s=612x612&w=0&h=6DcPO6xYTQ64DpFlxqRDepkV9t58K8fjbHfZnUGCbOs=
---

This post serves as a study guide. All the information has been obtained from public sources. You can find all links used at the end of each section.

<Section section="Process Synchronization">
  
  ### Process

  <Box question="What is a process?">
    We can define a process as a program that is currently being executed.
  </Box>

  <Box question="What are the states of a process?">

      - Ready: ready for execution
      - Running: executing process
      - Blocked: waiting or blocked until another process gives the all clear

      ![States of a Process](https://media.geeksforgeeks.org/wp-content/uploads/20220114144811/state-660x365.PNG)

  </Box>

  <Box question="What are the types of concurrent unit control?">
      - Physical Concurrency
      - Logical Concurrency

      <Box question="when do they occurr?">
          - Phyical occurs when two or more processors are running simultaneously
          - Logical happens when execution happens in intervals in a single processor
      </Box>

  </Box>

  <Box question="How do concurrent processes interact with each other?">
    - shared variables: processes read and write to shared memory 
      - ![Shared Svariables](https://web.mit.edu/6.005/www/fa14/classes/17-concurrency/figures/shared-memory.png)
    - message passing: messages are sent through communication channels 
      -![Message passing](https://web.mit.edu/6.005/www/fa14/classes/17-concurrency/figures/message-passing.png)
  </Box>

  ### Critical Sections

  <Box question="What is a critical section?">
    Region of code that needs to be executed atomically since resources are shared
  </Box>

  <Box question="Solution to the critical section problem?">
    - <Box question="Busy Waiting">
        Technique in which a process/task waits and constantly checks for a condition to be satisfied before proceeding with its execution
        ![Busy Waiting](https://www.baeldung.com/wp-content/uploads/sites/4/2021/08/Busywaiting.svg)
      </Box>
    - <Box question="Disabling Interrupts">
        - The CPU will be unable to switch processes
        - Processes can use shared variables without another process accessing it
      </Box>
    - <Box question="Test-and-Set Intruction">
        - Shared variable is lock which is initialized to false
        - Algorithm returns value that was sent and sets lock to true
        ```c
          boolean lock = false;

          boolean TestAndSet (boolean &target){
              boolean rv = target;
              target = true;
              return rv;
          }

          while(1){
              while (TestAndSet(lock));
              critical section
              lock = false;
              remainder section
          }
        ```
      </Box>
  </Box>

  ### Semaphores

  <Box question="What is a semaphore?">
    It is similar to an integer but differs in:
      - value can only be increased or decreased. No reading occurs
      - after decreasing, if the value is negative then the thread is blocked until the semaphore is positive
      - once a thread is released and increases the value of the semaphore, one waiting thread gets accesss
  </Box>

  <Box question="Does the semaphore have atomic operations?">
    Yes
    - P(S): decrements the value
    - V(S): increments the value 

    ```c
    sem = Semaphore(1)

    // Process
    sem.P()
      // critical section
    sem.V()
    ```
  </Box>

  <Box question="Why use semaphores?">
    - Solutions are clean
    - Solutions are portable and efficient
  </Box>

  <Box question="Difference between locks, mutex semaphore?">
    - lock allows only one thread to enter the part that's locked and the lock is not shared with any other processes
    - mutex is the same as a lock but it can be system wide
    - semaphore does the same as a mutex but allows x number of threads to enter
  </Box>

  #### Producer Consumer Problem

  <Box question="What is this Producer Consumer Problem?">
    Producer threads create items and place them in a buffer, meanwhile consumer threads remove them from the buffer.
    Producer threads should not be able to create items if the buffer is full, and consumers should not be able to remove items if buffer is empty. 
  </Box>

  <Box question="Infinite Buffer Example">
    Code can be found on page 57 of Litte Book of semaphores

    ```ts
      buffer: number[] = [];
      mutex: semaphore = 1;
      items: semaphore = 0;
      
      Producer {
        mutex.P() // lock the mutex
          buffer.add(item)
          items.V() // increase number of items for consumer threads
        mutex.V() // release mutex
      }

      Consumer {
        items.P() // decrease number of items
        mutex.P() 
          buffer.pop() // remove item from buffer
        mutex.V()
      }
    ```
    <Box question="What is wrong with this implementation? How to fix it?">
      <Box question="Producer">
          Assume $mutex = 1$ at the start of the producer.
          1. mutex.P() inside Producer makes $mutex = 0$
          2. items.V() inside Producer can trigger a consumer thread
          3. items.P() inside Consumer makes $mutex = -1$
          4. mutex.V() inside Producer makes $mutex = 0$
          
          This means we cannot enter the critical section inside the consumer. In order to proceed the semaphore value has to be greater than 0

          The fix is to signal the consumer after we are out of the critical section.

          ```ts
            buffer: number[] = [];
            mutex: semaphore = 1;
            items: semaphore = 0;
            
            Producer {
              mutex.P() // lock the mutex
                buffer.add(item)
              mutex.V() // release mutex
              items.V() // increase number of items and signal consumer threads
            }
          ```
      </Box>
    
      <Box question="Consumer">
        Various consumers can decrement value of items before popping. This leads to incorrect count. Consider this:

        ```ts
            Consumer {
              mutex.P() 
                items.P() // decrease number of items
                buffer.pop() // remove item from buffer
              mutex.V()
            }

        ```
        Assume $items = 0$
        1. The consumer thread grabs the mutex
        2. items.P() in Consumer gets stuck since the value is not greater than 0
        3. Producer thread cannot increment the value of items, since it's waiting on the consumer to release the mutex

        We have reached a deadlock.
      </Box>
    </Box> 
  </Box>

  <Box question="Finite Buffer Example">

    Recall that a producer cannot create new items if buffer is full. Also, the consumer cannot retrieve items if buffer is empty. 

    ```ts
    const bufferSize: number = N;
    items: semaphore = 0;
    ...
    if (items >= bufferSize)
      block()
    ...
    ```

    <Box question="Would this work?">
      No, we cannot read the value of a semaphore. Only increase and decrease.
    </Box>

    <Box question = "Solution">
      We can add one more semaphore and set it equal to the size of the buffer.
      
      ```ts
        buffer: number[bufferSize];
        mutex: semaphore = 1;
        items: semaphore = 0;
        spaces: semaphore = bufferSize;

        Producer {
          spaces.P(); // decrement number of available spaces
          mutex.P();
            buffer.add()
          mutex.V();
          items.V() // signal the consumer
        }

        Consumer {
          items.P(); // decrement number of items in buffer
          mutex.P();
            buffer.pop();
          mutex.V();
          spaces.V(); // increment spaces
        }
      ```
    </Box>
  </Box>


  #### Readers-Writers Problem

  Little Book of Semaphores 4.2

  <Box question="What is the readers-writers problem?">
    Occurs when a resource is read and written by concurrent threads. Ideally, you do not want to read the resource while it is being written.
  </Box>

  <Box question="What are the constraints?">
    - Multiple readers can be in the critical section simultaneously
    - Writers have exclusive access to the critical section
  </Box>

  <Box question="Implementation">

    ```ts
      isRoomEmpty: semaphore = 1;
      mutex: semaphore = 1;
      readers: number = 0;

      Reader {
        mutex.P();
          readers++;
          if(readers == 1) isRoomEmpty.P(); // first reader locks the room
        mutex.V();

        <READ/>

        mutex.P();
          readers--;
          if(readers == 0) isRoomEmpty.V(); // last readers frees the room
        mutex.V();
      }

      Writer {
        isRoomEmpty.P(); // writer waits for room to be empty
          <WRITE/>
        isRoomEmpty.V();
      }
    ```
  </Box>

  <Box question="Starvation">
    In the previous implementation, writers can starve. This means that readers can keep coming in and writers _might_ wait forever. 

    <Box question="Make it so that when a writer arrives, exisiting readers finish.">
        ```ts
          isRoomEmpty: semaphore = 1;
          mutex: semaphore = 1;
          turnstile: semaphore = 1;
          readers: number = 0;

          Reader {
            turnstile.P(); // decrease number
            turnstile.V(); // the final increase to reach 1 is given by the writer

            mutex.P();
              readers++;
              if(readers == 1) isRoomEmpty.P(); // first reader locks the room
            mutex.V();

            <READ/>

            mutex.P();
              readers--;
              if(readers == 0) isRoomEmpty.V(); // last readers frees the room
            mutex.V();
          }

          Writer {
            turnstile.P(); // let readers know a writer came in
            isRoomEmpty.P(); // writer waits for room to be empty
              <WRITE/>
            turnstile.V(); // notify readers
            isRoomEmpty.V(); // room is ready
          }
        ```
    </Box>
  </Box>

  <Box question="Writer priority">
    Little Book of Semaphores page 79
        ```ts
          readerMutex: semaphore = 1;
          readers: number = 0;

          writerMutex: semaphore = 1;
          writers: number = 0;

          allowReaders: semaphore = 1;
          allowWriters: semaphore = 1;

          Reader {
            allowReaders.P();
              readerMutex.P();
                readers++;
                if(readers == 1) allowWriters.P(); // notify writers that readers are there
              readerMutex.V();
            allowReaders.V();

            <READ/>

            readerMutex.P();
              readers--;
              if(readers == 0) allowWriters.V(); //signal writers the are no more readers
            readerMutex.V();
          }

          Writer {
            writerMutex.P();
              writers++;
              if (writers == 1) allowReaders.P(); // notify readers to wait
            writerMutex.V();

            allowWriters.P();
              <WRITE/>
            allowWriters.V();

            writerMutex.P();
              writers--;
              if(writers == 0) allowReaders.V();
            writerMutex.V();
          }
        ```
  </Box>

  #### Dining Philosophers Problem

  Little Book of Semaphores 4.4

  <Box question="What is the Dining Philosophers Problem?">

    ![Dining Philosophers Problem](https://w3.cs.jmu.edu/kirkpams/OpenCSF/Books/csf/html/_images/CSF-Images.8.3.png)

    A philosopher needs _two_ forks to eat. Looking at the diagram, we can tell some of them will have to wait for an adjacent philosopher to finish eating.

    Each philosopher, representing a thread, runs the following loop:

    ```ts
      while (true) {
        think();
        getForks();
        eat();
        putForks();
      }
    ```

    Each philosopher knows their number ranging from 0 to $n$. Each fork is also numbered from 0 to $n$. A philosopher $i$ grabs the left fork $i$ and the right fork $i+1$

    The problem lies in the function $getForks()$ and $putForks()$. We need to implement them such that:
    - Only one philosopher can hold a fork at a time
    - No deadlocks
    - No starvation
    - Multiple philosophers eating
  </Box>


  <Box question="Solutions">
    ```ts
      const getForks = (i: number) => {
        forks[getLeft(i)].P();
        forks[getRight(i)].P();
      }

      const putForks = (i: number) => {
        forks[getLeft(i)].V();
        forks[getRight(i)].V();
      }
    ```
    <Box question="Does this solution work?">
      No. Imagine each philosopher picks up the fork to the right. There are no more forks available, and each philosphre only has one fork. No one can eat, thus leading to a deadlock.
    </Box>

    <Box question="Can it be improved?">
      We can ensure no deadlock as long as we leave one fork available. Say there are 5 forks, 5 philosophers, but we only allow 4 to eat. In the scenario where everyone reaches for a fork on the right, there will be one spare fork since one philosopher is not eating.
      We can implement this with a semaphore initialized to $n-1$, $n$ being the number of philosophers.

      ```ts
        maxPhilosophers: semaphore = n - 1;

        const getForks = (i: number) => {
          maxPhilosophers.P(); // only the first n - 1 philosophers can proceed

          forks[getLeft(i)].P();
          forks[getRight(i)].P();
        }

        const putForks = (i: number) => {
          forks[getLeft(i)].V();
          forks[getRight(i)].V();

          maxPhilosophers.V(); // notify the waiting philopher they can eat
        }
      ```
    </Box>
  </Box>

  ### Monitors

  <Box question="What is a monitor?">
    Collection of variables and procedures. Kinda like a class. 

    ```ts
      interface Condition {
        wait, // Process performing will be suspended and placed in the local queue
        signal, // One of the queued processes is popped
        queue // local queue of pending processes 
      }

      Monitor Test{
        variables: any;
        myConditions: Condition;

        procedure pn {...}
      }
    ```
  </Box>

  <Box question="Properties of monitors">
    - Outside processes cannot access the monitor's variables, but can call the procedures
    - Only one process at a time can execute code inside the monitor
  </Box>

  #### Producer Consumer Problem

  <Box question="Implementation">

    ```ts
    Monitor ProducerConsumer {
      items: number = 0; // # of items inside buffer
      full: condition;
      empty: condition;

      Procedure Produce {
        if (items == N) full.wait(); // can't produce since buffer is full
        <PRODUCE/> // should have released the wait
        items++;
        empty.signal(); // notify buffer is NOT empty & consumer can proceed
      }

      Procedure Consume {
        if (items == 0) empty.wait(); // can't consume since buffer is empty
        <CONSUME/>
        items--;
        full.signal(); // notify producer buffer is no longer full
      }
    }
    ```
  </Box>

  #### Readers-Writers Problem
  <Box question="Readers Priority">

    ```ts
    Monitor ReaderWriter {
      readers: number = 0;
      busy: boolean = false;
      reader: condition;
      writer: condition;

      Procedure beginRead {
        if (busy) reader.wait(); // wait until writer is done
        readers++;
        reader.signal(); // signal readers
      }

      Procedure endRead {
        reader--;
        if(readers == 0) writers.signal(); // notify writers there are no more readers
      }

      Procedure beginWrite {
        if(readers > 0 || busy) writer.wait(); // either reading or writing in process
        busy = true; // preparation
        writer.signal(); // notify writer it can proceed
      }

      Procedure endWrite {
        busy = false; // writer has finished
        if(reader.queue) reader.signal(); // notify reader it can proceed
        else writer.signal(); // if no readers, go to writer
      }
    }
    ```
  </Box>

  Geeks for Geeks:
  <Box question="Semaphores vs Monitors">
    - Mutual exclusion in monitors is automatic while in semaphores, mutual exclusion needs to be implemented explicitly.
    - Shared variables are global to all processes in the monitor while shared variables are hidden in semaphores
    - Semaphores permit more than one thread to access the critical section, unlike monitors.
    - In semaphores there is no spinning, hence no waste of resources due to no busy waiting.
  </Box>

  ### References
  <Box question="Sources">
    All the information is my understaning from the following sources. 
    - [Three State Process Model in Operating System](https://www.geeksforgeeks.org/three-state-process-model-in-operating-system/)
    - [What Does “Busy Waiting” Mean in Operating Systems?](https://www.baeldung.com/cs/os-busy-waiting)
    - [What is mutual exclusion by using interrupt disabling?](https://www.tutorialspoint.com/what-is-mutual-exclusion-by-using-interrupt-disabling#:~:text=Whenever%20the%20interrupts%20are%20disabled,without%20another%20process%20accessing%20it.)
    - [Hardware Synchronization Algorithms : Unlock and Lock, Test and Set, Swap](https://www.geeksforgeeks.org/hardware-synchronization-algorithms-unlock-and-lock-test-and-set-swap/)
    - [Little Book of Semaphores](https://greenteapress.com/semaphores/LittleBookOfSemaphores.pdf)
    - [What is the difference between lock, mutex and semaphore?](https://stackoverflow.com/questions/2332765/what-is-the-difference-between-lock-mutex-and-semaphore)
    - [Monitors in Process Synchronization](https://www.geeksforgeeks.org/monitors-in-process-synchronization/)
    - [Monitor vs Semaphore](https://www.geeksforgeeks.org/monitor-vs-semaphore/)
  </Box>



</Section>


