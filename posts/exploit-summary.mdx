---
author: Marcelo Morales
title: Exploit Summary
banner: https://image.shutterstock.com/image-vector/glitched-attention-danger-symbol-computer-600w-1135176134.jpg
type: Research
---

Notes on attacks. Each attack contains a section with references.


<Section section="Indexed Attack">
    - $16m worth of assets were stolen from the indices DEFI5 and CC10

    ### Automated Makert Makers (AMM)

    - Automated decentralized exchange where trades are made against a pool of tokens
    - Algorithm regulates the values and prices of the tokens in the liquidity pools
    - Example: Uniswap, Curve, and Balancer

    ### Index Fund

    An index fund is a pool of different assets in various ratios or balances.

    Traditional Finance:
    - portfolio manager manually trades to bring funds back to intended balance

    Decentralized Finance:
    - the fund rebalances automatically when trade occurs

    ### Balancer

    - Crypto pools function as weighted index fund

    - Maintain portfolios of up to eight different ERC-20 tokens

    - Balancer uses its constant mean market maker equation to automatically rebalance assets within pools via algorithm every time a trade is made

    - Balancer crypto exchange trading fees are paid directly to liquidity providers

    - Dillon immediately knew that the exploit was linked to a particular function related to how new assets are introduced to the pool. “As soon as we saw SUSHI tokens in the DEFI5 index, we knew—that had to be it,” 

    - The exploit included more than 1,000 events, and the transaction bundle took up an entire block on the blockchain.


    #### How to handle new assets

    - Uniswap oracle determines token price when introduced to the Balancer pool

    - extrapolatePoolValueFromToken inside IndexPool.sol
        - finds token in pool with target weight over 0 and is initialized
        - pool's balance is multiplied by inverse of found token's weight 



    ```ts

        // Array of underlying tokens in the pool.
        address[] internal _tokens;

        // Internal records of the pool's underlying tokens
        mapping(address => Record) internal _records;

        // Total denormalized weight of the pool.
        uint256 internal _totalWeight;

        function extrapolatePoolValueFromToken()
        external
        view
        override
        _viewlock_
        returns (address/* token */, uint256/* extrapolatedValue */)
        {
        address token;
        uint256 extrapolatedValue;
        uint256 len = _tokens.length;
        for (uint256 i = 0; i < len; i++) {
            token = _tokens[i];
            Record storage record = _records[token];
            if (record.ready && record.desiredDenorm > 0) { // token is initialized and has a valid target weight
            extrapolatedValue = bmul(
                record.balance,
                bdiv(_totalWeight, record.denorm) // multiply poo'ls weight by inverse of token
            );
            break;
            }
        }
        require(extrapolatedValue > 0, "ERR_NONE_READY");
        return (token, extrapolatedValue);
        }
    ```

    In simple terms, the value of the whole pool is extrapolated by:
    $ totalValue = tokenBalance \times \frac{totalWeight}{tokenWeight}$


    #### Example 
    Assume:
    - $ tokenWeight = 10 $
    - $ tokenBalance = 50 $
    - $ totalWeight = 100 $

    $$ totalValue = tokenBalance \times \frac{totalWeight}{tokenWeight} $$ 

    $$ totalValue = 50 \times \frac{100}{10} $$

    $$ totalValue = 500 $$

    #### Ideal Scenario
    - if a swap takes out a $tokenBalance = 25 $UNI, 
    - then $ tokenWeight = 5 $ 
    - in order to mantain a consistent pool value: $$ 25 \times \frac{100}{5} = 500 $$

    #### The 1% Cap and Issues
    - A drop like in the ideal scenario makes the AMM unusable due to impacts on trades

    - As a result, there is a 1% cap on how much a weight can drop by the hour

    - Making it look like this:
        - $$ 25 \times \frac{100}{9} = 297 $$


    - Anything depending on the pool's balance is subject to manipulation, for example, the *updateMinimumBalance()* function

    - Resets the virtual balance for an uninitialized token when token prices change so quickly that the minimum balance is so far off of the value of 1% of the pool that no one is willing to swap it into the pool.


    ```ts
    /**
    * @dev Updates the minimum balance of an uninitialized token, which is
    * useful when the token's price on the pool is too low relative to
    * external prices for people to trade it in.
    */
    function updateMinimumBalance(IIndexPool pool, address tokenAddress) external _havePool(address(pool)) {
        IIndexPool.Record memory record = pool.getTokenRecord(tokenAddress);
        require(!record.ready, "ERR_TOKEN_READY");
        uint256 poolValue = _estimatePoolValue(pool); // this function calls extrapolatePoolValueFromToken()
        PriceLibrary.TwoWayAveragePrice memory price = oracle.computeTwoWayAveragePrice(
        tokenAddress,
        SHORT_TWAP_MIN_TIME_ELAPSED,
        SHORT_TWAP_MAX_TIME_ELAPSED
        );
        uint256 minimumBalance = price.computeAverageTokensForEth(poolValue) / 100;
        pool.setMinimumBalance(tokenAddress, minimumBalance);
    }

    ```


    ### Attack

    First token found was Uniswap (UNI) in CC10(index)

    1. minimum balance for SUSHI was set to about $126k
    2. Exploit contract took out $156M of flash loans in UNI from Sushiswap and Uniswap V2
    3. Exploit contract bought UNI from the pool in chunks
        - pool caps sending in more 1/2 of existing balance in a token
        - pool caps buying 1/3 of pool's balance in a token
    4. Attacker execute minimum balance update on controller
    5. Controller queries balance of UNI
        - due to attacker buying most of UNI, its balance was low
        - pool was calculated as SUSHI $300k
    6. Attacker begins to deposit over-weighted SUSHI into the pool
    7. Attacker mints liquidity pool(LP) tokens 
    8. Attacker burns LP tokens 
    9. Attacker pays back flash loans



    <Box question="Sources">
        - [Indexed Attack Post-Mortem](https://ndxfi.medium.com/indexed-attack-post-mortem-b006094f0bdc)
        - [Balancer: The Most Versatile Automated Market Maker](https://www.gemini.com/cryptopedia/balancer-crypto-automated-pools)
        - [Cryptopedia Glossary](https://www.gemini.com/cryptopedia/glossary#index-fund)
        - [INDEXED FINANCE - REKT](https://rekt.news/indexed-finance-rekt/)
        - [Dillon Kellar - Developer](https://twitter.com/d1ll0nk/status/1448856748467630085)
        - [IndexPool Contract](https://etherscan.io/address/0x5bD628141c62a901E0a83E630ce5FaFa95bBdeE4#code#F5#L945)
        - [Mudit Gupta - Technical Perspective](https://twitter.com/Mudit__Gupta/status/1448884940964188167)
    </Box>
</Section>

## xToken Exploiter 

- On 29 August 2021, a vulnerability in our xSNX contract was exploited
- Loss to holders at $4.5 million

### dydx

- DeFi borrowing and lending platform built on the Ethereum blockchain
- A flash loan is a financial tool that enables users to borrow any amount of digital assets from a certain protocol pool with no collateral or proof of income
- they were popularized by dYdX.

### Aave

- Aave is a decentralised non-custodial liquidity market protocol where users can participate as depositors or borrowers

### SNX

- Ethereum token that powers Synthetix, a decentralised synthetic asset issuance protocol
- Synthetic assets are minted when token holders stake their SNX as collateral using Mintr
- Mintr is a decentralised application for interacting with the Synthetix contracts.

### Bancor & Kyber

#### Bancor
- only DeFi trading and staking protocol with Single-Sided Liquidity
- invented the first automated market maker (AMM) Liquidity pool in 2017

#### Kyber
- decentralized, blockchain-based protocol that aggregates liquidity and enables the exchange of tokens without an intermediary


### Attack

The Attacker:
1. Borrows 25k ETH from dydx 
2. Borrows 1m SNX from Aave
3. Swaps 6.8 ETH for 519k SNX on Bancor
    - 1.5m SNX own by attacker
4. Swaps 1.5m SNX on Kyber for 6.5m USDC 
    - lowers price of SNX
5. Swap 6.5m USDC for sUSD on Curve
6. Transfers 2m sUSD to xSNXAdmin contract
    - xSNXAdmin contract holds the assets managed by xSNX
    - with intention of repaying the contract’s sUSD debt in order to unlock SNX
7. Call of the *callFunction* function on xSNXAdmin contract, burning outstanding sUSD debt and swapping ~614k SNX for ~811k sUSD debt at artificially depressed price 
8. swap of ~811k sUSD for ~811k USDC, which remains in the contract
9. Swap back to ETH and repay loans

- *callFunction*  should only have been callable from dydx’s SoloMargin flashloan contract
- vulnerability: called by attacker

Snippet:

```ts
    // Broken:
    require(sender=address(this))

    // Ideal:
    require(msg.sender==soloMarginAddress)
```


<Box question="Sources">
    - [xSNX Post Mortem](https://medium.com/xtoken/xsnx-post-mortem-666d35071f38)
    - [EXPLAINED: THE XTOKEN HACK (AUGUST 2021)](https://halborn.com/explained-the-xtoken-hack-august-2021/)
    - [Transaction Link](https://etherscan.io/tx/0x924e6a6288587b497f73ddcf6ae3c184f15ab35dfcb85f3074b55266974029ef)
    - [What is dYdX?](https://decrypt.co/resources/dydx-ethereum-margin-trading-platform-explained-learn)
    - [What Is a Flash Loan in dYdX?](https://defipedia.com/answers/decentralized-finance/what-is-a-flash-loan-in-dydx)
    - [Synthetix Network Token SNX](https://www.coinbase.com/price/synthetix-network-token#:~:text=SNX%20is%20the%20native%20token,provide%20liquidity%20and%20earn%20yield.)
    - [Aave](https://aave.com/)
    - [What is Bancor?](https://support.bancor.network/hc/en-us/articles/4415811872530-What-is-Bancor-)
</Box>